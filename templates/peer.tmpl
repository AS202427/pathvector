{{- $peer := .Peer }}{{ $peerName := .Name }}{{ $global := .Config -}}

# {{ .Name }} AS{{ .Peer.ASN }}

define AS{{ .Peer.ASN }}_{{ .Name }}_MAXPFX_v4 = {{ .Peer.ImportLimit4 }};
define AS{{ .Peer.ASN }}_{{ .Name }}_MAXPFX_v6 = {{ .Peer.ImportLimit6 }};

{{ if .Peer.FilterIRR -}}
{{ if NotEmpty .Peer.PrefixSet4 }}
define AS{{ .Peer.ASN }}_{{ .Name }}_PFX_v4 = [
{{ BirdSet .Peer.PrefixSet4 }}
];
{{ end }}

{{ if NotEmpty .Peer.PrefixSet6 }}
define AS{{ .Peer.ASN }}_{{ .Name }}_PFX_v6 = [
{{ BirdSet .Peer.PrefixSet6 }}
];
{{ end }}
{{ end -}}

{{- range $i, $neighbor := $peer.NeighborIPs -}}
{{ $af := "4" }}{{- if Contains $neighbor ":" }}{{ $af = "6" }}{{ end }}
protocol bgp {{ $peer.ProtocolName }}v{{ $af }}_{{ $i }} {
    local{{ if $peer.Listen }} {{ $peer.Listen }}{{ end }} as ASN{{ if $peer.LocalPort }} port {{ $peer.LocalPort }}{{ end }};
    neighbor {{ $neighbor }} as {{ $peer.ASN }}{{ if $peer.NeighborPort }} port {{ $peer.NeighborPort }}{{ end }};
    {{- if $peer.Description }}description "{{ $peer.Description }}";{{ end }}
    {{- if $peer.Disabled }}disabled;{{ end }}
    {{- if $peer.Passive }}passive;{{ end }}
    {{- if $peer.Multihop }}multihop 255;{{ end }}
    {{- if $peer.Password }}password "{{ $peer.Password }}";{{ end }}
    {{- if $peer.RSClient }}rs client;{{ end }}
    {{- if $peer.RRClient }}rr client;{{ end }}
    {{- if $peer.BFD }}bfd on;{{ end }}
    {{ $peer.SessionGlobal }}
    {{- $protocols := MakeSlice }}
    {{- if $peer.MPUnicast46 }}
        {{- $protocols = MakeSlice "4" "6" }}
    {{ else }}
        {{- $protocols = MakeSlice $af }}
    {{ end }}
    {{- range $i, $af := $protocols -}}
    ipv{{ $af }} {
        {{ if $global.KeepFiltered -}}
        import keep filtered;
        {{ end -}}
        import limit AS{{ $peer.ASN }}_{{ $peerName }}_MAXPFX_v{{ $af }} action {{ $peer.MaxPrefixTripAction }};
        {{ if or (eq $peer.ASN $global.ASN) ($peer.NextHopSelf) }}next hop self;{{ end }}
        import filter {

            {{- $peer.PreImport }}
            {{ if $peer.FilterBogons }}reject_bogons();{{ end }}
            {{ if $peer.EnforceFirstAS }}enforce_first_as({{ $peer.ASN }});{{ end }}
            {{ if $peer.EnforcePeerNexthop }}enforce_peer_nexthop({{ $neighbor }});{{ end }}
            strip_info_communities();
            bgp_local_pref = {{ $peer.LocalPref }};
            honor_graceful_shutdown();
            {{- if $peer.AllowBlackholeCommunity }}process_blackholes();{{ end }}
            {{- if $peer.FilterTier1ASNs }}reject_transit_paths();{{ end }}
            {{- if $peer.FilterIRR }}
            if (net ~ AS{{ $peer.ASN }}_{{ $peerName }}_PFX_v{{ $af }}) then {
                accept;
            } else {
                reject;
            }
            {{ end -}}
            {{ $peer.PreImportFinal }}
            accept;
        };

        export filter {

            {{- $peer.PreExport }}

            {{- range $i, $community := $global.LargeCommunities }}
            bgp_large_community.add(({{ $community }}));
            {{ end -}}

            {{- range $i, $community := $global.Communities -}}
            bgp_community.add(({{ $community }}));
            {{ end -}}

            {{- range $i, $community := $peer.Communities -}}
            bgp_community.add(({{ $community }}));
            {{ end -}}

            {{- range $i, $community := $peer.LargeCommunities -}}
            bgp_large_community.add(({{ $community }}));
            {{ end -}}

            {{- if $peer.RemovePrivateASNs }}bgp_path.delete([64512..65534, 4200000000..4294967294]); # Strip private ASNs{{ end }}

            {{- range $i := Iterate $peer.Prepends }}
            bgp_path.prepend(ASN);
            {{ end -}}
            
            {{- if or $global.Prefixes4 $global.Prefixes6 }}
            process_prepends();
            accept_local(); # Originated
            {{ end -}}

            {{- if not $peer.AnnounceSpecifics }}
            if ((ASN,1,200) ~ bgp_large_community) then reject; # Don't export to upstreams
            if ((ASN,0,103) ~ bgp_large_community) then accept; # Downstream
            if ((ASN,0,102) ~ bgp_large_community) then accept; # Peer
            if ((ASN,0,101) ~ bgp_large_community) then accept; # Upstream
            {{ end -}}

            {{- if $peer.AnnounceDefault }}if (proto = "default{{ $af }}") then accept; # Send default route{{ end -}}
            {{ $peer.PreExportFinal -}}

            reject;
        };
    };
    {{- end }}
}
{{ end }}
